# PrototypePatternHW
### Иерархия классов «Компьютерная техника»

Device -> Computer -> Laptop -> GamingLaptop

1.  Device (Устройство) - основной родительский класс.
    * Поля: BrandName (бренд), ModelName (модель), SerialNumber (серийный номер).
2.  Computer (Компьютер) — наследует Device.
    * Поля: ProcessorName (процессор), RamSize (объем ОЗУ).
3.  Laptop (Ноутбук) — наследует Computer.
    * Поля: ScreenSize (диагональ экрана), Weight (вес), BatteryLife (время работы от аккумулятора).
4.  GamingLaptop (Игровой ноутбук) — наследует Laptop.
    * Поля: GpuModel (модель видеокарты), HasRgbBackLight (Наличие RGB-подсветки).

### Описание тестов
1.  TestIMyCloneableImplementation(): Проверяет, что свой дженерик интерфейс IMyCloneable<T> корректно создает новый объект.
2.  TestICloneableImplementation(): Проверка создания объекта, с использованием стандартного ICloneable. Дополнительно проверяет, что возвращаемый тип - GamingLaptop, а не просто object.
3.  TestFieldsEquals(): Проверяет, что все поля (включая унаследованные) скопировались правильно.
4.  TestChangeField(): Проверяет, что объект-клон независим от оригинала. У клона изменено поле SerialNumber, проверяется, что оно отличается, а остальные поля совпадают.

### Преимущества и недостатки IMyCloneable и ICloneable
Преимущества ICloneable
   * стандартизация;
   * обеспечение обратной совместимости.

Недостатки ICloneable: 
   * возвращает object, что заставляет постоянно делать приведение типов ((MyClass)obj.Clone());
   * упаковка в object может снижать производительность;
   * неопределенность реализации (поверхностное или глубокое клонирование?).

Преимущества IMyCloneable: 
   * строгая типизация;
   * возвращает конкретный тип;
   * делает код более понятным и удобным потому что каждый класс может возвращать самого себя в цепочке наследования;
   * не требует приведения;
   * отсутствует лишняя работа по упаковке/распаковке типов.

Недостатки IMyCloneable:
   * интерфейс пользовательский, его могут не знать другие разработчики или внешние библиотеки;
   * приходится скрывать родительские методы на каждом уровне наследования.

### Вывод
Использование собственного интерфейса клонирования предпочтительнее, так как оно соответствует принципам типобезопасности и делает код более понятным и удобным. В то же время поддержка ICloneable может быть полезна для обеспечения обратной совместимости.
